package com.griffith.helpmedecide
/*
* Name: Zainab Wadullah
* BSCH - Stage 4 MD
* Student Number: 3088942
* */
import android.graphics.Paint
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.core.*
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.rotate
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlin.math.cos
import kotlin.math.sin
import kotlin.random.Random

var items : List<String>? = null
class SpinTheWheel : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            //This gets the list from the generate list activity!
            //This will be a dummy until the GPS stuff is completed
            val segments = listOf("A", "B", "C", "D", "E", "F","G","H") //list of items
            items = intent.getStringArrayListExtra("ITEMS_LIST")?.toMutableList() ?: emptyList<String>()
            val IS_USER_GENERATED = intent.getBooleanExtra("IS_USER_GENERATED", false)
            items = intent.getStringArrayListExtra("RESTAURANT_LIST")?.toMutableList() ?: emptyList<String>()
            val LOCATION_GENERATED = intent.getBooleanExtra("LOCATION_GENERATED", false)
            Surface(
                modifier = Modifier.fillMaxSize(),
                color = Color.Blue
            ) {
                if(IS_USER_GENERATED){ //Generated by the user
                    SpinWheelDraw(segments = items!!)
                } else if(LOCATION_GENERATED){
                    SpinWheelDraw(segments =items!!)
                } else { //Generated by GPS specific stuff :)
                    SpinWheelDraw(segments = segments)
                }
            }
        }
    }
}

@Composable
fun SpinWheelDraw(segments: List<String>) {
    var isSpinning by remember { mutableStateOf(false) }
    var currentRotation by remember { mutableFloatStateOf(0f) }
    var targetRotation by remember { mutableFloatStateOf(0f) }
    var selectedItem by remember { mutableStateOf("") }
    var highlightedItem by remember { mutableStateOf(segments.first()) } // Tracks current item
    var showDialog by remember { mutableStateOf(false) }

    val animatedRotation by animateFloatAsState(
        targetValue = targetRotation,
        animationSpec = tween(
            durationMillis = 4000,
            easing = FastOutSlowInEasing
        ),
        finishedListener = {
            isSpinning = false
            val normalizedRotation = targetRotation % 360
            val segmentAngle = 360f / segments.size
            val pointerAngle = 0f
            val adjustedAngle = (normalizedRotation + pointerAngle) % 360
            val selectedIndex = ((360 - adjustedAngle) / segmentAngle).toInt() % segments.size
            selectedItem = segments[selectedIndex]
            showDialog = true
        }
    )

    LaunchedEffect(animatedRotation) {
        if (isSpinning) {
            val normalizedRotation = animatedRotation % 360
            val segmentAngle = 360f / segments.size
            val adjustedAngle = (360 - normalizedRotation) % 360
            val highlightedIndex = (adjustedAngle / segmentAngle).toInt() % segments.size
            highlightedItem = segments[highlightedIndex]
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(LocalContext.current.getColor(R.color.light_purple)))
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Row( //Just a title card
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.Center,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Card(
                border = BorderStroke(1.dp, Color.White),
                modifier = Modifier
                    .size(width = 300.dp, height = 100.dp)
                    .padding(16.dp),
                elevation = CardDefaults.cardElevation(
                    defaultElevation = 3.dp
                ),
            ) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "We're choosing...",
                        fontSize = 20.sp,
                        textAlign = TextAlign.Center
                    )
                }
            }
        }
        Text( //show the user the choices cuz its satisfying
            text = highlightedItem,
            fontSize = 24.sp,
            color = Color.White,
            modifier = Modifier.padding(bottom = 16.dp)
        )
        DrawTheWheel(rotationAngle = animatedRotation, segments = segments)
        Spacer(modifier = Modifier.height(16.dp)) //space between
        Button(
            colors = ButtonDefaults.buttonColors(
                containerColor = Color(LocalContext.current.getColor(R.color.light_green)),
                contentColor = Color(LocalContext.current.getColor(R.color.black))
            ),
            onClick = {
                if (!isSpinning) { //triggers the spinning animation
                    currentRotation = targetRotation //if its 0 it doesnt spin well after the first spin
                    val randomEndAngle = Random.nextInt(0, 360) //to randomise the choices
                    val fullRotations = 5 * 360 //animation choice
                    targetRotation = currentRotation + fullRotations + randomEndAngle
                    isSpinning = true
                }
            }
        ) {
            Text(text = "Spin the Wheel")
        }
    }

    if (showDialog) { //if its ok to show it
        ShowPopupDialog(selectedItem) { //selected item from the wheel
            showDialog = false
        }
    }
}

@Composable
fun DrawTheWheel(rotationAngle: Float, segments : List<String>) {
    val context = LocalContext.current //to get the colors from xml file
    val colors = listOf( //list of colors for the wheel
        Color(context.getColor(R.color.teal_700)),
        Color(context.getColor(R.color.dark_blue_custom)),
        Color(context.getColor(R.color.light_green)))
    Box{ //using canvas to draw the wheel
        Canvas(modifier = Modifier.size(300.dp)) {
            val canvasSize = size.minDimension //define canvas size
            val radius = canvasSize / 2 //radius of the circle
            val center = Offset(size.width / 2, size.height / 2)
            val segmentAngle = 360f / segments.size
            //rotate the little arcs
            rotate(degrees = rotationAngle-90f, pivot = center) {
                for (i in segments.indices) {
                    val color = colors[i % 3]
                    drawArc(
                        color = color,
                        startAngle = i * segmentAngle,
                        sweepAngle = segmentAngle,
                        useCenter = true,
                        size = Size(canvasSize, canvasSize),
                        topLeft = Offset((size.width - canvasSize) / 2, (size.height - canvasSize) / 2)
                    )
                    Log.d("StartAngle", "${i * segmentAngle}")
                    val textAngle = (i * segmentAngle + segmentAngle / 2)
                    val textRadius = radius * 0.7f
                    val x = center.x + textRadius * cos(Math.toRadians(textAngle.toDouble())).toFloat()
                    val y = center.y + textRadius * sin(Math.toRadians(textAngle.toDouble())).toFloat()

                    drawContext.canvas.nativeCanvas.apply {
                        save()
                        //Truncate the strings, because when theyre too long they look ugly
                        val paint = Paint().apply {
                            textSize = 50f
                            textAlign = Paint.Align.CENTER
                        }
                        val maxWidth = 200f
                        var textToDraw = segments[i]
                        while (paint.measureText(textToDraw) > maxWidth && textToDraw.isNotEmpty()) {
                            textToDraw = textToDraw.dropLast(1) // Remove the last character
                        }
                        if (textToDraw != segments[i]) {
                            textToDraw = textToDraw.dropLast(3)
                        }
                        drawText(
                            textToDraw,
                            x,
                            y,
                            Paint().apply {
                                setColor(context.getColor(R.color.off_white))
                                textSize = 50f
                                textAlign = Paint.Align.CENTER
                            }
                        )
                        restore()
                    }
                }
            }
            //circle in the middle
            drawCircle(color = Color.White, radius = radius * 0.1f, center = center)
            //Little trianlge thing
            val trianglePath = androidx.compose.ui.graphics.Path().apply {
                moveTo(center.x - 15f, center.y - radius - 20f)
                lineTo(center.x + 15f, center.y - radius - 20f)
                lineTo(center.x, center.y - radius + 40f)
                close()
            }
            drawPath(path = trianglePath, color = Color.White)
        }
    }

}

@Composable //popup dialog with string and onDismiss :)
fun ShowPopupDialog(item: String, onDismiss: () -> Unit) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(item) },
        text = { Text("The wheel stopped on: $item") },
        confirmButton = {
            Row{
                Button(onClick = onDismiss) {
                    Text("Try Again")
                }
            }
        }
    )
}

//@Preview
//@Composable
//fun PreviewPopupDialog(){
//    ShowPopupDialog(item = "HI") { }
//}

//To debug and stuff
@Preview(showBackground = true)
@Composable
fun PreviewSpinWheelApp() {
    SpinWheelDraw(segments = listOf("1", "2", "3", "4", "5", "6"))
}
